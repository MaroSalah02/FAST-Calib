// Generated by gencpp from file livox_ros_driver/CustomMsg.msg
// DO NOT EDIT!


#ifndef LIVOX_ROS_DRIVER_MESSAGE_CUSTOMMSG_H
#define LIVOX_ROS_DRIVER_MESSAGE_CUSTOMMSG_H

#include <string>
#include <vector>
#include <array>
#include <memory>

#include <rclcpp/rclcpp.hpp>
#include <std_msgs/msg/header.hpp>
#include "CustomPoint.h"

namespace livox_ros_driver
{
namespace msg
{

struct CustomMsg
{
  // Message fields
  std_msgs::msg::Header header;
  uint64_t timebase;
  uint32_t point_num;
  uint8_t lidar_id;
  std::array<uint8_t, 3> rsvd;
  std::vector<livox_ros_driver::msg::CustomPoint> points;

  // Constructors
  CustomMsg()
    : header()
    , timebase(0)
    , point_num(0)
    , lidar_id(0)
    , rsvd{{0, 0, 0}}
    , points()
  {
  }

  explicit CustomMsg(const std::allocator<void>&)
    : CustomMsg()
  {
  }

  // Type aliases for ROS 2
  using SharedPtr = std::shared_ptr<CustomMsg>;
  using ConstSharedPtr = std::shared_ptr<const CustomMsg>;
  using UniquePtr = std::unique_ptr<CustomMsg>;
  using ConstUniquePtr = std::unique_ptr<const CustomMsg>;

  // Message type info
  static constexpr const char* MESSAGE_TYPE = "livox_ros_driver/msg/CustomMsg";
  static constexpr bool HAS_HEADER = true;
};

// Type aliases for convenience
using CustomMsgSharedPtr = std::shared_ptr<livox_ros_driver::msg::CustomMsg>;
using CustomMsgConstSharedPtr = std::shared_ptr<const livox_ros_driver::msg::CustomMsg>;

} // namespace msg
} // namespace livox_ros_driver

// ROS 2 type support (simplified - in a real implementation this would be generated)
namespace rclcpp
{
namespace serialization
{

template<>
struct Serializer<livox_ros_driver::msg::CustomMsg>
{
  // This would normally be generated by ROS 2 build system
  // For now, we'll use standard PointCloud2 conversion
};

} // namespace serialization
} // namespace rclcpp

#endif // LIVOX_ROS_DRIVER_MESSAGE_CUSTOMMSG_H
